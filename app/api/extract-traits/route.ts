import sharp from 'sharp';

export const maxDuration = 60;

interface BoundingBox {
    left: number;
    top: number;
    width: number;
    height: number;
}

export async function POST(req: Request) {
    try {
        const { imageData } = await req.json();

        console.log('âœ‚ï¸ Extracting traits from sprite sheet...');

        // Remove data URL prefix if present
        const base64Data = imageData.replace(/^data:image\/\w+;base64,/, '');
        const buffer = Buffer.from(base64Data, 'base64');

        // Load image with Sharp
        const image = sharp(buffer);
        const metadata = await image.metadata();
        const { width, height } = metadata;

        if (!width || !height) {
            throw new Error('Invalid image dimensions');
        }

        console.log(`ðŸ“ Image size: ${width}x${height}`);

        // Convert to raw pixel data for analysis
        const { data, info } = await image
            .raw()
            .toBuffer({ resolveWithObject: true });

        // Define background colors to check against
        // 1. Yellowish-green (RGB: 148, 196, 111) - commonly generated by Gemini
        // 2. Pure bright green (RGB: 0, 255, 0) - generated when AI follows prompt strictly
        const TARGETS = [
            { r: 148, g: 196, b: 111 }, // Yellowish-green
            { r: 0, g: 255, b: 0 },     // Pure green
            { r: 120, g: 227, b: 43 }   // Rick & Morty Lime Green
        ];

        const GREEN_THRESHOLD = 60; // Tolerance for region detection
        const CLEANING_THRESHOLD = 80; // More aggressive tolerance for cleaning fringing

        const isGreen = (r: number, g: number, b: number, threshold = GREEN_THRESHOLD): boolean => {
            // Check against all target greens
            return TARGETS.some(target => {
                const diff = Math.abs(r - target.r) + Math.abs(g - target.g) + Math.abs(b - target.b);
                return diff < threshold;
            });
        };

        const getPixel = (x: number, y: number): { r: number, g: number, b: number, a: number } => {
            const idx = (y * info.width + x) * info.channels;
            return {
                r: data[idx],
                g: data[idx + 1],
                b: data[idx + 2],
                a: info.channels === 4 ? data[idx + 3] : 255
            };
        };

        // Find all non-background regions
        const visited = new Set<string>();
        const regions: BoundingBox[] = [];
        const MIN_REGION_SIZE = 1000; // Lowered threshold for smaller assets

        // Flood fill to find connected regions
        const floodFill = (startX: number, startY: number): BoundingBox | null => {
            const queue: [number, number][] = [[startX, startY]];
            let minX = startX, maxX = startX;
            let minY = startY, maxY = startY;
            let pixelCount = 0;

            const hasAlpha = info.channels === 4;

            while (queue.length > 0) {
                const [x, y] = queue.shift()!;
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                if (x < 0 || x >= info.width || y < 0 || y >= info.height) continue;

                const pixel = getPixel(x, y);

                // Define "Background" condition
                let isBackground = false;
                if (hasAlpha && pixel.a < 20) {
                    isBackground = true; // Transparent
                } else if (isGreen(pixel.r, pixel.g, pixel.b)) {
                    isBackground = true; // Green check fallback
                }

                if (isBackground) continue;

                visited.add(key);
                pixelCount++;

                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);

                // Add neighbors
                const step = 2; // Optimization: skip pixels for speed
                queue.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }

            // Filter out tiny regions (noise)
            if (pixelCount < MIN_REGION_SIZE) return null;

            return {
                left: minX,
                top: minY,
                width: maxX - minX + 1,
                height: maxY - minY + 1
            };
        };

        // Scan for regions
        const hasAlpha = info.channels === 4;

        for (let y = 0; y < info.height; y += 5) {
            for (let x = 0; x < info.width; x += 5) {
                if (visited.has(`${x},${y}`)) continue;

                const pixel = getPixel(x, y);
                let isBackground = false;

                if (hasAlpha && pixel.a < 20) {
                    isBackground = true;
                } else if (isGreen(pixel.r, pixel.g, pixel.b)) {
                    isBackground = true;
                }

                if (!isBackground) {
                    const region = floodFill(x, y);
                    if (region) {
                        regions.push(region);
                    }
                }
            }
        }

        console.log(`ðŸ” Found ${regions.length} regions`);

        // Extract each region as a separate image
        const extractedTraits = await Promise.all(
            regions.map(async (region, index) => {
                // Add padding and ensure bounds are within image
                const padding = 10;
                const left = Math.max(0, region.left - padding);
                const top = Math.max(0, region.top - padding);
                const right = Math.min(info.width, region.left + region.width + padding);
                const bottom = Math.min(info.height, region.top + region.height + padding);

                const extractRegion = {
                    left,
                    top,
                    width: right - left,
                    height: bottom - top
                };

                // Crop the region
                const croppedBuffer = await sharp(buffer)
                    .extract(extractRegion)
                    .toBuffer();

                // Manual background removal with conservative threshold
                // Preserves grey colors in characters while removing background
                const transparentBuffer = await sharp(croppedBuffer)
                    .removeAlpha()
                    .ensureAlpha()
                    .raw()
                    .toBuffer({ resolveWithObject: true });

                const { data: pixelData, info: cropInfo } = transparentBuffer;
                for (let i = 0; i < pixelData.length; i += 4) {
                    const r = pixelData[i];
                    const g = pixelData[i + 1];
                    const b = pixelData[i + 2];

                    // Only remove pixels VERY close to green background
                    // Use stricter cleaning threshold to remove fringing
                    if (isGreen(r, g, b, CLEANING_THRESHOLD)) {
                        pixelData[i + 3] = 0;
                    }
                }

                // Convert back to PNG with transparency and TRIM empty space (padding)
                // This is crucial for correct alignment calculations
                const finalBuffer = await sharp(pixelData, {
                    raw: {
                        width: cropInfo.width,
                        height: cropInfo.height,
                        channels: 4
                    }
                })
                    .png()
                    .trim() // Remove transparent border/padding
                    .toBuffer();

                const base64 = finalBuffer.toString('base64');
                const dataUrl = `data:image/png;base64,${base64}`;

                return {
                    index,
                    imageUrl: dataUrl,
                    boundingBox: region
                };
            })
        );

        console.log(`âœ… Extracted ${extractedTraits.length} traits`);

        return new Response(JSON.stringify({
            traits: extractedTraits,
            totalFound: extractedTraits.length
        }), {
            status: 200,
            headers: { 'Content-Type': 'application/json' }
        });

    } catch (error: any) {
        console.error("âŒ Trait extraction failed:", error);
        return new Response(JSON.stringify({
            error: error.message || "Failed to extract traits"
        }), { status: 500 });
    }
}

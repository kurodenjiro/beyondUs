
import { GoogleGenAI } from "@google/genai";
import * as fs from "fs";
import * as path from "path";
import * as dotenv from "dotenv";
import * as readline from "readline";

// Load environment variables from .env.local
dotenv.config({ path: ".env.local" });

const apiKey = process.env.GOOGLE_AI_API_KEY || process.env.GEMINI_API_KEY;

if (!apiKey) {
    console.error("‚ùå No API key found. Please set GOOGLE_AI_API_KEY or GEMINI_API_KEY in .env.local");
    process.exit(1);
}

const ai = new GoogleGenAI({ apiKey });

// --- CONFIGURATION ---
const OUTPUT_DIR = "generated-traits";
const BATCH_SIZE_PER_LAYER = 3; // Generate 3 variations of variable traits
const CANVAS_WIDTH = 1024;
const CANVAS_HEIGHT = 1024;

// Fixed seed for base layers to ensure consistency
const BASE_SEED = 42069;
const COMBINATION_SEED = 11111;

// --- PROMPT TEMPLATES ---
const FIXED_BASE_PROMPT_TEMPLATE = `
A minimalist 2D flat vector NFT base layer of {{TRAIT_NAME}}.
{{BASE_INSTRUCTION}}

Positioned at x=512, y={{Y}} on a {{WIDTH}}x{{HEIGHT}} white canvas.

Perfectly symmetrical, clean sharp edges.
Isolated on a solid white background.
No shadows, no gradients, no textures.
Flat design, high contrast.
Production-ready NFT base.
`;

const VARIABLE_TRAIT_PROMPT_TEMPLATE = `
A minimalist 2D flat vector NFT trait of {{TRAIT_NAME}} 
for the {{LAYER_TYPE}} layer, variation {{INDEX}}.

{{BASE_INSTRUCTION}}

Positioned at x={{X}}, y={{Y}} on a {{WIDTH}}x{{HEIGHT}} white canvas.

Design features {{STYLE_DESCRIPTOR}}, 
consistent with the same NFT collection art style.

Perfectly symmetrical, clean sharp edges.
Isolated on a solid white background.

{{EXTRA_NEGATIVE}}

No shadows, no gradients, no textures.
Flat design, high contrast.
Production-ready NFT trait.
`;

// --- DATA STRUCTURES ---

interface BaseLayerConfig {
    layerType: string;
    prompt: string;
    y: number;
}

interface VariableLayerConfig {
    layerType: string;
    names: string[];
    styles: string[];
    x: number;
    y: number;
    baseInstruction: string;
    extraNegative: string;
}

// User-Defined Fixed Bases
const FIXED_BASES: BaseLayerConfig[] = [
    {
        layerType: "body_base",
        prompt: "Headless human body base, neutral A-pose, tan skin, centered.",
        y: 800
    },
    {
        layerType: "head_base",
        prompt: "Large-scale bald head, neutral expression, matching skin tone, centered.",
        y: 512
    }
];

// Variable Layers to be generated by AI
let VARIABLE_LAYERS: VariableLayerConfig[] = [];

// --- HELPER FUNCTIONS ---

function askQuestion(query: string): Promise<string> {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });

    return new Promise(resolve => rl.question(query, ans => {
        rl.close();
        resolve(ans);
    }));
}

async function generateVariableConfig(theme: string): Promise<VariableLayerConfig[]> {
    console.log(`üß† Brainstorming traits for theme: "${theme}"...`);

    const prompt = `
    You are an expert NFT project creative director.
    The user wants an NFT collection based on the theme: "${theme}".

    We have a fixed "body_base" (headless human) and a "head_base" (bald head).
    You need to generate variations for these 3 VARIABLE layers:
    1. "clothing_wear" (Fits ON TOP of body_base)
    2. "eye_trait" (Fits ON face of head_base)
    3. "hat_trait" (Fits ON TOP of head_base)

    For EACH of these 3 layers, provide 5 unique creative names and 5 corresponding visual style descriptors.

    Output strictly valid JSON with this structure:
    [
      {
        "layerType": "clothing_wear",
        "names": ["Name1", "Name2", ...],
        "styles": ["Style1", "Style2", ...],
        "x": 512,
        "y": 800,
        "baseInstruction": "Character outfit trait, hollow inside to fit the body_base exactly, A-pose sleeves, no body visible.",
        "extraNegative": "Do not draw the head or hands, only the clothing."
      },
      {
        "layerType": "eye_trait",
        "names": ["Name1", "Name2", ...],
        "styles": ["Style1", "Style2", ...],
        "x": 512,
        "y": 420,
        "baseInstruction": "Pair of eyes, matching the scale of the head_base, isolated.",
        "extraNegative": "Do not draw the whole head. Do not draw the nose or mouth. Only the eyes."
      },
      {
        "layerType": "hat_trait",
        "names": ["Name1", "Name2", ...],
        "styles": ["Style1", "Style2", ...],
        "x": 512,
        "y": 512,
        "baseInstruction": "Headwear trait, scaled for head_base, front-facing.",
        "extraNegative": "Do not draw the face."
      }
    ]
    `;

    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.0-flash-exp",
            contents: {
                role: "user",
                parts: [{ text: prompt }]
            },
            config: {
                responseMimeType: "application/json"
            }
        });

        const text = response.candidates?.[0]?.content?.parts?.[0]?.text;
        if (!text) throw new Error("No text returned from AI");

        const jsonStr = text.replace(/```json/g, '').replace(/```/g, '').trim();
        const configs = JSON.parse(jsonStr);

        console.log("‚úÖ Configuration generated!");
        return configs;

    } catch (error: any) {
        console.error("‚ùå Failed to generate config:", error.message);
        process.exit(1);
    }
}

async function generateImage(prompt: string, filename: string, outputDir: string, seed?: number): Promise<string | null> {
    const filepath = path.join(outputDir, filename);

    console.log(`üé® Generating: ${filename}${seed ? ` (seed: ${seed})` : ''}...`);

    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash-image",
            contents: {
                role: "user",
                parts: [{ text: prompt }]
            },
            config: seed ? {
                seed: seed,
                temperature: 0.3  // Lower temperature for more consistency
            } : undefined
        });

        const candidate = response.candidates?.[0];
        const parts = candidate?.content?.parts || [];

        let imageData: string | null = null;

        for (const part of parts) {
            if (part.inlineData && part.inlineData.data) {
                imageData = part.inlineData.data;
                break;
            }
        }

        if (!imageData) {
            console.error(`‚ùå No image data found for ${filename}`);
            return null;
        }

        const buffer = Buffer.from(imageData, 'base64');
        fs.writeFileSync(filepath, buffer);
        console.log(`‚úÖ Saved to ${filepath}`);

        return filepath;

    } catch (error: any) {
        console.error(`‚ùå Gen failed:`, error.message);
        return null;
    }
}

async function generateBasePose(outputDir: string): Promise<void> {
    console.log("\nüß¨ Combining body and head into base pose...");

    const bodyPath = path.join(outputDir, "body_base.png");
    const headPath = path.join(outputDir, "head_base.png");

    if (!fs.existsSync(bodyPath) || !fs.existsSync(headPath)) {
        console.error("‚ùå Missing body or head base!");
        return;
    }

    const bodyBuffer = fs.readFileSync(bodyPath);
    const headBuffer = fs.readFileSync(headPath);

    const inputParts = [
        {
            text: `
            Combine these 2 base layers into a single, complete human character base pose.
            
            Instructions:
            1. Place the HEAD on top of the BODY's neck
            2. Ensure perfect vertical alignment (neck to torso)
            3. Create a neutral A-pose character
            4. Frontal 2D sprite view
            5. White background
            6. This will be the BASE POSE for all NFT variations
            
            CRITICAL: This must be perfectly centered and symmetrical.
            `
        },
        {
            inlineData: {
                mimeType: "image/png",
                data: bodyBuffer.toString("base64")
            }
        },
        {
            inlineData: {
                mimeType: "image/png",
                data: headBuffer.toString("base64")
            }
        }
    ];

    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash-image",
            contents: {
                role: "user",
                parts: inputParts
            },
            config: {
                seed: BASE_SEED,
                temperature: 0.3
            }
        });

        const imagePart = response.candidates?.[0]?.content?.parts?.find(p => p.inlineData?.data);

        if (!imagePart || !imagePart.inlineData?.data) {
            console.error("‚ùå Failed to generate base pose");
            return;
        }

        const buffer = Buffer.from(imagePart.inlineData.data, 'base64');
        const basePosePath = path.join(outputDir, "base_pose.png");
        fs.writeFileSync(basePosePath, buffer);
        console.log(`‚úÖ Base pose saved to ${basePosePath}`);

    } catch (error: any) {
        console.error("‚ùå Base pose generation failed:", error.message);
    }
}

async function combineTraitsWithAI(outputDir: string, theme: string, index: number) {
    console.log(`\nü§ñ [${index}] Asking AI to combine traits into preview NFT...`);

    // Use the base_pose as foundation, then add variable traits
    const layers = [
        "base_pose.png",  // The complete body+head base
        `trait_${index}_clothing_wear.png`,
        `trait_${index}_eye_trait.png`,
        `trait_${index}_hat_trait.png`
    ];

    const inputParts = [];

    inputParts.push({
        text: `
        I have generated a BASE POSE and 3 variable trait layers.
        The theme is: "${theme}".
        
        Please OVERLAY the traits onto the base pose to create the final NFT character.

        Project: beyoundUS
        Version: 1.0

        Prompt Configuration:
        - Subject: ${theme} Character (Constructed from traits)
        - Pose:
          - Body: neutral A-pose, standing upright
          - Head: centered, facing forward, eyes level
          - Alignment: perfectly vertical neck-to-torso transition
        - Technical Constraints:
          - View: frontal 2D sprite
          - Background: solid hex #FFFFFF
          - Padding: 20% border safety zone
        - Style: clean vector line art, flat colors, NFT trait compatible

        Negative Prompt: tilted head, perspective distortion, cropped, off-center, asymmetrical
        
        Layer Order (Stacking):
        1. BASE: base_pose (Complete body + head foundation)
        2. Layer 2: clothing_wear (Overlay on body)
        3. Layer 3: eye_trait (Overlay on face)
        4. Layer 4: hat_trait (Overlay on head)
        
        Rules:
        1. **CRITICAL: The 'base_pose' MUST remain EXACTLY the same.** Do not modify the base pose.
        2. **Use the base_pose as the immutable foundation.**
        3. **REDRAW the clothing, eyes, and hat traits to fit perfectly onto the base pose:**
           - Clothing: Redraw to match the exact body shape, pose, and proportions
           - Eyes: Redraw to fit the exact face position and head angle
           - Hat: Redraw to fit the exact head size and position
        4. **Consistency Check:** All 3 variations must have IDENTICAL body posture and position (only traits differ).
        5. Maintain the minimalist 2D vector style. White background.
        6. The final result should look like a single cohesive character, not separate layers.
        `
    });

    for (const filename of layers) {
        const filepath = path.join(outputDir, filename);
        if (fs.existsSync(filepath)) {
            const imageBuffer = fs.readFileSync(filepath);
            const base64Image = imageBuffer.toString("base64");

            inputParts.push({
                inlineData: {
                    mimeType: "image/png",
                    data: base64Image
                }
            });
            console.log(`üì¶ Loaded layer: ${filename}`);
        } else {
            console.warn(`‚ö†Ô∏è Missing layer: ${filename}`);
        }
    }

    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash-image",
            contents: {
                role: "user",
                parts: inputParts
            },
            config: {
                seed: COMBINATION_SEED,
                temperature: 0.3  // Lower temperature for consistent composition
            }
        });

        const textPart = response.candidates?.[0]?.content?.parts?.find(p => p.text)?.text; // Sometimes it returns text too
        const imagePart = response.candidates?.[0]?.content?.parts?.find(p => p.inlineData?.data);

        if (!imagePart || !imagePart.inlineData?.data) {
            console.error(`‚ùå AI did not return a combined image for index ${index}.`);
            return;
        }

        const buffer = Buffer.from(imagePart.inlineData.data, 'base64');
        const previewPath = path.join(outputDir, `preview_nft_ai_${index}.png`);
        fs.writeFileSync(previewPath, buffer);
        console.log(`‚ú® AI Generated Preview saved to ${previewPath}`);

    } catch (error: any) {
        console.error("‚ùå AI Combination failed:", error.message);
    }
}

// --- MAIN LOOP ---
async function main() {
    console.log("üöÄ Starting Batch Trait Generation...");

    // Get user theme
    const theme = await askQuestion("Enter the NFT Theme (e.g., 'Cyberpunk Pigeons', 'Retro Robots'): ");
    if (!theme) {
        console.error("Theme is required!");
        process.exit(1);
    }

    // Ensure output dir exists
    if (!fs.existsSync(OUTPUT_DIR)) {
        fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }

    // 1. Generate Fixed Bases (Once)
    console.log("\n--- generating Fixed Bases ---");
    for (const base of FIXED_BASES) {
        const prompt = FIXED_BASE_PROMPT_TEMPLATE
            .replace("{{TRAIT_NAME}}", base.layerType.replace("_", " "))
            .replace("{{BASE_INSTRUCTION}}", base.prompt)
            .replace("{{Y}}", base.y.toString())
            .replace("{{WIDTH}}", CANVAS_WIDTH.toString())
            .replace("{{HEIGHT}}", CANVAS_HEIGHT.toString());

        await generateImage(prompt, `${base.layerType}.png`, OUTPUT_DIR, BASE_SEED);
    }

    // 1.5. Combine body and head into complete base pose
    await generateBasePose(OUTPUT_DIR);

    // 2. Generate Variable Config
    VARIABLE_LAYERS = await generateVariableConfig(theme);

    // 3. Generate Variable Traits
    for (const config of VARIABLE_LAYERS) {
        console.log(`\n--- Processing Layer: ${config.layerType} ---`);
        for (let i = 1; i <= BATCH_SIZE_PER_LAYER; i++) {
            const traitName = config.names[i % config.names.length];
            const styleDescriptor = config.styles[i % config.styles.length];

            const prompt = VARIABLE_TRAIT_PROMPT_TEMPLATE
                .replace("{{TRAIT_NAME}}", traitName)
                .replace("{{LAYER_TYPE}}", config.layerType)
                .replace("{{INDEX}}", i.toString())
                .replace("{{BASE_INSTRUCTION}}", config.baseInstruction)
                .replace("{{X}}", config.x.toString())
                .replace("{{Y}}", config.y.toString())
                .replace("{{WIDTH}}", CANVAS_WIDTH.toString())
                .replace("{{HEIGHT}}", CANVAS_HEIGHT.toString())
                .replace("{{STYLE_DESCRIPTOR}}", styleDescriptor)
                .replace("{{EXTRA_NEGATIVE}}", config.extraNegative);

            await generateImage(prompt, `trait_${i}_${config.layerType}.png`, OUTPUT_DIR);
        }
    }

    // 4. Combine
    console.log("\n--- Starting Combination Phase ---");
    for (let i = 1; i <= BATCH_SIZE_PER_LAYER; i++) {
        await combineTraitsWithAI(OUTPUT_DIR, theme, i);
    }

    console.log("\n‚ú® Process Complete!");
}

main().catch(console.error);
